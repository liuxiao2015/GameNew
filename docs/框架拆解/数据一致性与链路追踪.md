# 数据一致性与链路追踪

本文档描述框架在分布式环境下保证数据一致性的机制，以及跨服务的链路追踪能力。

---

## 一、数据一致性

### 1.1 一致性工具矩阵

| 工具 | 适用场景 | 复杂度 | 一致性保证 |
|-----|---------|-------|-----------|
| IdempotentService | 防止重复操作 | 低 | 幂等性 |
| CompensationService | 失败后补偿 | 中 | 最终一致 |
| SagaService | 多步骤事务 | 高 | 最终一致 |
| LockService | 临界区保护 | 低 | 强一致 |

---

### 1.2 幂等性服务

防止同一操作重复执行（如道具发放、订单处理）。

```java
@Autowired
private IdempotentService idempotentService;

// 使用唯一 key 保证幂等
var result = idempotentService.execute(
    "reward:" + orderId,         // 幂等 key
    Duration.ofHours(24),        // 过期时间
    () -> {
        return giveReward(roleId, items);
    }
);

if (result.isDuplicate()) {
    log.info("订单已处理过: orderId={}", orderId);
    return result.getExistingResult();  // 返回之前的结果
}

return result.getNewResult();
```

---

### 1.3 补偿服务

当操作失败时，自动执行补偿逻辑。

```java
@Autowired
private CompensationService compensationService;

// 1. 注册补偿处理器（服务启动时）
compensationService.registerHandler("guild:donate", record -> {
    // 补偿逻辑：返还玩家金币
    playerService.addGold(record.getRoleId(), record.getData("amount"));
    log.info("补偿玩家金币: roleId={}, amount={}", 
            record.getRoleId(), record.getData("amount"));
});

// 2. 执行可补偿操作
boolean success = compensationService.executeWithCompensation(
    "guild:donate",              // 补偿类型
    roleId,                      // 关联角色
    Map.of("amount", 1000),      // 补偿所需数据
    () -> {
        playerService.deductGold(roleId, 1000);
        guildService.addFund(guildId, 1000);
        return true;
    }
);
```

---

### 1.4 Saga 模式

编排多步骤分布式事务，任一步骤失败自动回滚。

```java
@Autowired
private SagaService sagaService;

SagaResult result = sagaService.begin()
    .name("公会交易")
    .step("扣除金币",
        () -> playerService.deductGold(roleId, 1000),  // 正向操作
        () -> playerService.addGold(roleId, 1000))     // 补偿操作
    .step("增加公会资金",
        () -> guildService.addFund(guildId, 1000),
        () -> guildService.deductFund(guildId, 1000))
    .step("发放奖励",
        () -> rewardService.sendReward(roleId, reward),
        () -> rewardService.revokeReward(roleId, reward))
    .execute();

if (!result.isSuccess()) {
    log.error("Saga 执行失败: failedStep={}", result.getFailedStep());
    // 所有之前的步骤已自动补偿
}
```

---

### 1.5 分布式锁

保护临界区，防止并发问题。

```java
@Autowired
private LockService lockService;

// 简单使用
lockService.executeWithLock("order:" + orderId, () -> {
    createOrder();
});

// 带返回值
Order order = lockService.executeWithLock("order:" + orderId, () -> {
    return createOrder();
});

// 带重试
lockService.executeWithLock("trade", 3, 100, () -> {
    doTrade();
});
```

---

## 二、链路追踪

### 2.1 自动 traceId 传递

框架自动在所有 Dubbo RPC 调用中传递 traceId。

```
请求处理流程:
┌─────────┐    ┌─────────┐    ┌─────────┐    ┌─────────┐
│ Gateway │───▶│  Game   │───▶│  Guild  │───▶│  Chat   │
│traceId:A│    │traceId:A│    │traceId:A│    │traceId:A│
└─────────┘    └─────────┘    └─────────┘    └─────────┘
                              同一个 traceId
```

### 2.2 TraceContext 使用

```java
// 获取当前 traceId
String traceId = TraceContext.getTraceId();

// 手动设置（通常不需要）
TraceContext.start();

// 清理（由框架自动处理）
TraceContext.end();
```

### 2.3 日志配置

```xml
<!-- logback-spring.xml -->
<pattern>
  %d{yyyy-MM-dd HH:mm:ss} [%X{traceId}] [%X{roleId}] %-5level %logger{36} - %msg%n
</pattern>
```

日志输出示例：

```
2026-01-23 10:30:15 [abc12345] [10001] INFO  PlayerHandler - 处理获取玩家信息
2026-01-23 10:30:15 [abc12345] [10001] INFO  GuildService  - 查询公会信息
2026-01-23 10:30:15 [abc12345] [10001] INFO  ChatService   - 获取聊天记录
```

### 2.4 DubboTraceFilter

框架自动注册的 Dubbo 过滤器，实现跨服务 traceId 传递。

```java
// 自动激活，无需配置
// Consumer 端：将 TraceContext 放入 RpcContext
// Provider 端：从 RpcContext 恢复 TraceContext
```

---

## 三、最佳实践

### 3.1 选择正确的一致性工具

| 场景 | 推荐工具 |
|-----|---------|
| 防止重复发奖 | IdempotentService |
| 单个服务内的并发控制 | LockService |
| 跨服务简单操作（可补偿） | CompensationService |
| 跨服务复杂事务 | SagaService |

### 3.2 幂等 Key 设计

```java
// 好的设计 - 业务唯一标识
"order:create:" + orderId
"reward:daily:" + roleId + ":" + date
"guild:donate:" + roleId + ":" + timestamp

// 差的设计 - 可能重复
"create_order"  // 不唯一
UUID.randomUUID()  // 每次都不同，无法防重
```

### 3.3 Saga 步骤设计

1. **正向操作必须幂等** - 重试时不会重复执行
2. **补偿操作必须能成功** - 不能依赖外部服务
3. **步骤顺序很重要** - 先扣减资源，后发放奖励

### 3.4 链路追踪调试

```java
// 在关键点记录 traceId
log.info("[trace:{}] 开始处理订单: orderId={}", 
        TraceContext.getTraceId(), orderId);

// 异步任务中保持 traceId
String traceId = TraceContext.getTraceId();
executor.submit(() -> {
    TraceContext.setTraceId(traceId);
    try {
        // 处理逻辑
    } finally {
        TraceContext.end();
    }
});
```

---

## 四、常见问题

### Q: 幂等 key 应该设置多长过期时间？

A: 根据业务场景决定：
- 订单类：24小时以上
- 日常奖励：到第二天0点
- 即时操作：5-10分钟

### Q: Saga 失败后如何排查？

A: 
1. 查看日志中的 traceId
2. 查看 `SagaResult.getFailedStep()` 获取失败步骤
3. 检查补偿日志确认回滚是否成功

### Q: 分布式锁超时怎么办？

A: 
1. 增加超时时间（不推荐）
2. 优化锁内逻辑，减少执行时间
3. 使用 `LockService` 的看门狗机制自动续期

---

**文档版本**: v1.0  
**最后更新**: 2026-01
